<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: sans-serif;
        }
        .data-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s;
        }
        .data-item:hover {
            background-color: #f9f9f9;
        }
        .data-item.selected {
            background-color: #e0f2fe; /* Light blue for selected items */
        }
        .data-item input[type="checkbox"] {
            margin-right: 12px;
            flex-shrink: 0;
        }
        .data-item > div {
            flex-grow: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px; /* Spacing between elements */
            overflow: hidden; /* Prevent long text from breaking layout */
        }
        .data-item .title {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-basis: 40%; /* Adjust as needed */
        }
        .data-item .details {
            font-size: 0.9em;
            color: #555;
            white-space: nowrap;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .data-item .status {
            font-size: 0.8em;
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .status-extracted {
            background-color: #d1fae5; /* Tailwind green-100 */
            color: #065f46; /* Tailwind green-800 */
        }
        .status-pending {
            background-color: #fef3c7; /* Tailwind yellow-100 */
            color: #92400e; /* Tailwind yellow-800 */
        }
        .file-header {
            background-color: #f3f4f6; /* Tailwind gray-100 */
            padding: 8px 12px;
            font-weight: bold;
            margin-top: 16px;
            border-bottom: 2px solid #e5e7eb; /* Tailwind gray-200 */
        }
        #action-buttons {
            position: sticky;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-top: 1px solid #ddd;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto p-4 sm:p-6">
        <header class="mb-6">
            <h1 class="text-2xl font-bold text-gray-800">Data Overview</h1>
        </header>

        <div id="data-container" class="bg-white rounded shadow overflow-hidden">
            <!-- Data will be loaded here -->
            <div id="loading" class="p-6 text-center text-gray-500">Loading data...</div>
        </div>

        <div id="action-buttons" class="hidden mt-4">
             <span id="selected-count" class="mr-4 self-center text-gray-600">0 items selected</span>
            <button id="complete-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">
                Mark Complete
            </button>
            <button id="delete-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">
                Delete Selected
            </button>
        </div>
    </div>

    <script>
        const dataContainer = document.getElementById('data-container');
        const loadingIndicator = document.getElementById('loading');
        const actionButtonsContainer = document.getElementById('action-buttons');
        const deleteButton = document.getElementById('delete-btn');
        const completeButton = document.getElementById('complete-btn');
        const selectedCountSpan = document.getElementById('selected-count');

        const filePaths = [
            'result/dummy001.json',
            'result/dummy002.json',
            'result/dummy003.json'
        ];

        let allData = {}; // Store data keyed by file path
        let selectedItems = new Set(); // Store unique IDs of selected items

        async function fetchData(filePath) {
            try {
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${filePath}`);
                }
                return await response.json();
            } catch (error) {
                console.error(`Error fetching ${filePath}:`, error);
                return []; // Return empty array on error
            }
        }

        function renderData() {
            dataContainer.innerHTML = ''; // Clear previous content

            filePaths.forEach(filePath => {
                const data = allData[filePath];
                if (!data || data.length === 0) return; // Skip if no data for this file

                // Add file header
                const fileHeader = document.createElement('div');
                fileHeader.className = 'file-header';
                fileHeader.textContent = filePath;
                dataContainer.appendChild(fileHeader);

                // Add data items
                data.forEach((item, index) => {
                    // Generate a unique ID for selection tracking
                    const uniqueId = `${filePath}-${index}`; // Use index as ID within the file

                    const itemElement = document.createElement('div');
                    itemElement.className = 'data-item';
                    itemElement.dataset.id = uniqueId;
                    itemElement.dataset.filePath = filePath;
                    itemElement.dataset.index = index; // Store original index

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.dataset.id = uniqueId;
                    checkbox.addEventListener('change', handleSelectionChange);

                    const contentDiv = document.createElement('div');

                    const titleSpan = document.createElement('span');
                    titleSpan.className = 'title';
                    titleSpan.textContent = item.title;
                    titleSpan.title = item.title; // Show full title on hover

                    const detailsSpan = document.createElement('span');
                    detailsSpan.className = 'details';
                    detailsSpan.textContent = `${item.city} | ${item.keyword} | ${item.fromDate} ~ ${item.toDate}`;

                    const statusSpan = document.createElement('span');
                    statusSpan.className = 'status';
                    if (item.extracted) {
                        statusSpan.classList.add('status-extracted');
                        statusSpan.textContent = 'Completed';
                    } else {
                        statusSpan.classList.add('status-pending');
                        statusSpan.textContent = 'Pending';
                    }

                    contentDiv.appendChild(titleSpan);
                    contentDiv.appendChild(detailsSpan);
                    contentDiv.appendChild(statusSpan);

                    itemElement.appendChild(checkbox);
                    itemElement.appendChild(contentDiv);
                    dataContainer.appendChild(itemElement);
                });
            });
        }

        function handleSelectionChange(event) {
            const checkbox = event.target;
            const uniqueId = checkbox.dataset.id;
            const itemElement = document.querySelector(`.data-item[data-id="${uniqueId}"]`);

            if (checkbox.checked) {
                selectedItems.add(uniqueId);
                itemElement.classList.add('selected');
            } else {
                selectedItems.delete(uniqueId);
                itemElement.classList.remove('selected');
            }
            updateActionButtons();
        }

        function updateActionButtons() {
            const count = selectedItems.size;
             selectedCountSpan.textContent = `${count} item${count !== 1 ? 's' : ''} selected`;
            if (count > 0) {
                actionButtonsContainer.classList.remove('hidden');
            } else {
                actionButtonsContainer.classList.add('hidden');
            }
        }

        function deleteSelectedItems() {
            if (selectedItems.size === 0) return;

            console.log("--- Deleting Items (UI Only) ---");
            const itemsToDeleteByFile = {};

            selectedItems.forEach(uniqueId => {
                const itemElement = document.querySelector(`.data-item[data-id="${uniqueId}"]`);
                if (itemElement) {
                    const filePath = itemElement.dataset.filePath;
                    const index = parseInt(itemElement.dataset.index, 10);

                    if (!itemsToDeleteByFile[filePath]) {
                        itemsToDeleteByFile[filePath] = [];
                    }
                    // Store the original index to identify the item in the JSON
                    itemsToDeleteByFile[filePath].push(index);

                    itemElement.remove(); // Remove from UI
                }
            });

            // Log intended changes (in a real app, this would trigger backend updates)
            for (const path in itemsToDeleteByFile) {
                console.log(`File: ${path}, Indices to delete: ${itemsToDeleteByFile[path].sort((a, b) => b - a).join(', ')}`);
                // Important: Indices need to be deleted in reverse order to avoid shifting issues
                const indicesToDelete = itemsToDeleteByFile[path].sort((a, b) => b - a); // Sort descending
                indicesToDelete.forEach(index => {
                    if (allData[path] && allData[path][index]) {
                         console.log(`Simulating deletion of: ${JSON.stringify(allData[path][index])}`);
                         allData[path].splice(index, 1); // Update in-memory data
                    }
                });
            }
             console.log("---------------------------------");


            selectedItems.clear();
            updateActionButtons();
            // Note: Actual file writing is not performed here.
            alert('Selected items removed from the view. File updates require backend implementation.');
        }

        function markSelectedItemsComplete() {
            if (selectedItems.size === 0) return;

            console.log("--- Marking Items Complete (UI Only) ---");
             const itemsToUpdateByFile = {};

            selectedItems.forEach(uniqueId => {
                const itemElement = document.querySelector(`.data-item[data-id="${uniqueId}"]`);
                 const checkbox = itemElement.querySelector('input[type="checkbox"]');
                if (itemElement) {
                    const filePath = itemElement.dataset.filePath;
                    const index = parseInt(itemElement.dataset.index, 10);

                     if (!itemsToUpdateByFile[filePath]) {
                        itemsToUpdateByFile[filePath] = [];
                    }
                    itemsToUpdateByFile[filePath].push(index);


                    // Update UI
                    const statusSpan = itemElement.querySelector('.status');
                    statusSpan.classList.remove('status-pending');
                    statusSpan.classList.add('status-extracted');
                    statusSpan.textContent = 'Completed';

                    // Update in-memory data
                    if (allData[filePath] && allData[filePath][index]) {
                        allData[filePath][index].extracted = true;
                         console.log(`Simulating update for: ${JSON.stringify(allData[filePath][index])}`);
                    }

                    // Uncheck and deselect
                    itemElement.classList.remove('selected');
                    if(checkbox) checkbox.checked = false;
                }
            });

             // Log intended changes
            for (const path in itemsToUpdateByFile) {
                console.log(`File: ${path}, Indices to mark complete: ${itemsToUpdateByFile[path].join(', ')}`);
            }
            console.log("--------------------------------------");

            selectedItems.clear();
            updateActionButtons();
            // Note: Actual file writing is not performed here.
             alert('Selected items marked as complete in the view. File updates require backend implementation.');
        }

        async function loadAllData() {
            loadingIndicator.classList.remove('hidden');
            dataContainer.innerHTML = ''; // Clear previous data/headers

            const promises = filePaths.map(async (filePath) => {
                const data = await fetchData(filePath);
                allData[filePath] = data; // Store fetched data
            });

            await Promise.all(promises);

            loadingIndicator.classList.add('hidden');
            renderData();
            updateActionButtons(); // Initial state
        }

        // Add event listeners to buttons
        deleteButton.addEventListener('click', deleteSelectedItems);
        completeButton.addEventListener('click', markSelectedItemsComplete);

        // Initial load
        loadAllData();
    </script>
</body>
</html>
