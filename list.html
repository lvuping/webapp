<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>데이터 뷰어</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Using a nicer sans-serif font */
        }
        .data-item {
            display: flex;
            align-items: center;
            /* Increased padding for better spacing */
            padding: 12px 16px;
            border-bottom: 1px solid #e5e7eb; /* Tailwind gray-200 */
            transition: background-color 0.2s;
        }
        .data-item:hover {
            background-color: #f3f4f6; /* Tailwind gray-100 */
        }
        .data-item.selected {
            background-color: #dbeafe; /* Tailwind blue-100 */
        }
        .data-item input[type="checkbox"] {
            margin-right: 16px; /* Increased margin */
            flex-shrink: 0;
        }
        .data-item > div {
            flex-grow: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px; /* Increased gap */
            overflow: hidden; /* Prevent long text from breaking layout */
        }
        .data-item .title {
            font-weight: 600; /* Slightly bolder */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-basis: 45%; /* Adjusted basis */
        }
        .data-item .details {
            font-size: 0.9em;
            color: #4b5563; /* Tailwind gray-600 */
            white-space: nowrap;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .data-item .status {
            font-size: 0.8em;
            padding: 3px 8px; /* Slightly larger padding */
            border-radius: 6px; /* More rounded */
            white-space: nowrap;
            flex-shrink: 0;
            font-weight: 500;
        }
        .status-extracted {
            background-color: #dcfce7; /* Tailwind green-100 */
            color: #166534; /* Tailwind green-800 */
        }
        .status-pending {
            background-color: #fef9c3; /* Tailwind yellow-100 */
            color: #854d0e; /* Tailwind yellow-800 */
        }
        .file-header {
            background-color: #e5e7eb; /* Tailwind gray-200 */
            padding: 10px 16px; /* Increased padding */
            font-weight: 600; /* Bolder */
            margin-top: 20px; /* Increased margin */
            border-bottom: 2px solid #d1d5db; /* Tailwind gray-300 */
            color: #374151; /* Tailwind gray-700 */
            font-size: 1.1em; /* Slightly larger font */
        }
        #action-buttons {
            position: sticky;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 12px 24px; /* Increased padding */
            border-top: 1px solid #d1d5db; /* Tailwind gray-300 */
            box-shadow: 0 -2px 6px rgba(0,0,0,0.08); /* Softer shadow */
            display: flex;
            gap: 12px; /* Increased gap */
            justify-content: flex-end;
        }
    </style>
    <!-- Add Google Font Inter for a cleaner look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100"> <!-- Slightly darker background -->
    <div class="container mx-auto p-4 sm:p-8"> <!-- Increased padding -->
        <header class="mb-8"> <!-- Increased margin -->
            <h1 class="text-3xl font-bold text-gray-900">데이터 개요</h1> <!-- Darker text, larger size -->
        </header>

        <div id="data-container" class="bg-white rounded-lg shadow-md overflow-hidden"> <!-- Added shadow-md, rounded-lg -->
            <!-- Data will be loaded here -->
            <div id="loading" class="p-8 text-center text-gray-600">데이터 로딩 중...</div> <!-- Increased padding -->
        </div>

        <div id="action-buttons" class="hidden mt-4">
             <span id="selected-count" class="mr-4 self-center text-gray-600">0개 선택됨</span>
            <button id="complete-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">
                완료 처리
            </button>
            <button id="delete-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">
                선택 삭제
            </button>
        </div>
    </div>

    <script>
        const dataContainer = document.getElementById('data-container');
        const loadingIndicator = document.getElementById('loading');
        const actionButtonsContainer = document.getElementById('action-buttons');
        const deleteButton = document.getElementById('delete-btn');
        const completeButton = document.getElementById('complete-btn');
        const selectedCountSpan = document.getElementById('selected-count');

        const filePaths = [
            'result/dummy001.json',
            'result/dummy002.json',
            'result/dummy003.json',
            'result/보일러수리_원주_2025-04-10T16-20-50.json' // Added this line
        ];

        let allData = {}; // Store data keyed by file path
        let selectedItems = new Set(); // Store unique IDs of selected items

        async function fetchData(filePath) {
            try {
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${filePath}`);
                }
                return await response.json();
            } catch (error) {
                console.error(`Error fetching ${filePath}:`, error);
                return []; // Return empty array on error
            }
        }

        function renderData() {
            dataContainer.innerHTML = ''; // Clear previous content

            filePaths.forEach(filePath => {
                const data = allData[filePath];
                if (!data || data.length === 0) return; // Skip if no data for this file

                // --- Create File Header with Keyword and City ---
                const fileHeader = document.createElement('div');
                fileHeader.className = 'file-header';

                // Extract keyword and city from the first item (if available)
                const firstItem = data[0];
                let headerText = filePath; // Default to file path
                if (firstItem && firstItem.keyword && firstItem.city) {
                    headerText = `${firstItem.keyword} - ${firstItem.city}`;
                } else if (firstItem && firstItem.keyword) {
                     headerText = firstItem.keyword; // Fallback if city is missing
                } else if (firstItem && firstItem.city) {
                     headerText = firstItem.city; // Fallback if keyword is missing
                }
                 // Add count of items in the file
                headerText += ` (${data.length}개 항목)`;

                fileHeader.textContent = headerText;
                dataContainer.appendChild(fileHeader);
                // --- End File Header Creation ---

                // Add data items
                data.forEach((item, index) => {
                    // Generate a unique ID for selection tracking
                    const uniqueId = `${filePath}-${index}`; // Use index as ID within the file

                    const itemElement = document.createElement('div');
                    itemElement.className = 'data-item';
                    itemElement.dataset.id = uniqueId;
                    itemElement.dataset.filePath = filePath;
                    itemElement.dataset.index = index; // Store original index

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.dataset.id = uniqueId;
                    checkbox.addEventListener('change', handleSelectionChange);

                    const contentDiv = document.createElement('div');

                    const titleSpan = document.createElement('span');
                    titleSpan.className = 'title';
                    titleSpan.textContent = item.title;
                    titleSpan.title = item.title; // Show full title on hover

                    const detailsSpan = document.createElement('span');
                    detailsSpan.className = 'details';
                    detailsSpan.textContent = `${item.city} | ${item.keyword} | ${item.fromDate} ~ ${item.toDate}`;

                    const statusSpan = document.createElement('span');
                    statusSpan.className = 'status';
                    if (item.extracted) {
                        statusSpan.classList.add('status-extracted');
                        statusSpan.textContent = '완료';
                    } else {
                        statusSpan.classList.add('status-pending');
                        statusSpan.textContent = '대기';
                    }

                    contentDiv.appendChild(titleSpan);
                    contentDiv.appendChild(detailsSpan);
                    contentDiv.appendChild(statusSpan);

                    itemElement.appendChild(checkbox);
                    itemElement.appendChild(contentDiv);
                    dataContainer.appendChild(itemElement);
                });
            });
        }

        function handleSelectionChange(event) {
            const checkbox = event.target;
            const uniqueId = checkbox.dataset.id;
            const itemElement = document.querySelector(`.data-item[data-id="${uniqueId}"]`);

            if (checkbox.checked) {
                selectedItems.add(uniqueId);
                itemElement.classList.add('selected');
            } else {
                selectedItems.delete(uniqueId);
                itemElement.classList.remove('selected');
            }
            updateActionButtons();
        }

        function updateActionButtons() {
            const count = selectedItems.size;
             selectedCountSpan.textContent = `${count}개 선택됨`;
            if (count > 0) {
                actionButtonsContainer.classList.remove('hidden');
            } else {
                actionButtonsContainer.classList.add('hidden');
            }
        }

        function deleteSelectedItems() {
            if (selectedItems.size === 0) return;

            console.log("--- Deleting Items (UI Only) ---");
            const itemsToDeleteByFile = {};

            selectedItems.forEach(uniqueId => {
                const itemElement = document.querySelector(`.data-item[data-id="${uniqueId}"]`);
                if (itemElement) {
                    const filePath = itemElement.dataset.filePath;
                    const index = parseInt(itemElement.dataset.index, 10);

                    if (!itemsToDeleteByFile[filePath]) {
                        itemsToDeleteByFile[filePath] = [];
                    }
                    // Store the original index to identify the item in the JSON
                    itemsToDeleteByFile[filePath].push(index);

                    itemElement.remove(); // Remove from UI
                }
            });

            // Log intended changes (in a real app, this would trigger backend updates)
            for (const path in itemsToDeleteByFile) {
                console.log(`File: ${path}, Indices to delete: ${itemsToDeleteByFile[path].sort((a, b) => b - a).join(', ')}`);
                // Important: Indices need to be deleted in reverse order to avoid shifting issues
                const indicesToDelete = itemsToDeleteByFile[path].sort((a, b) => b - a); // Sort descending
                indicesToDelete.forEach(index => {
                    if (allData[path] && allData[path][index]) {
                         console.log(`Simulating deletion of: ${JSON.stringify(allData[path][index])}`);
                         allData[path].splice(index, 1); // Update in-memory data
                    }
                });
            }
             console.log("---------------------------------");


            selectedItems.clear();
            updateActionButtons();
            // Note: Actual file writing is not performed here.
            alert('Selected items removed from the view. File updates require backend implementation.');
        }

        function markSelectedItemsComplete() {
            if (selectedItems.size === 0) return;

            console.log("--- Marking Items Complete (UI Only) ---");
             const itemsToUpdateByFile = {};

            selectedItems.forEach(uniqueId => {
                const itemElement = document.querySelector(`.data-item[data-id="${uniqueId}"]`);
                 const checkbox = itemElement.querySelector('input[type="checkbox"]');
                if (itemElement) {
                    const filePath = itemElement.dataset.filePath;
                    const index = parseInt(itemElement.dataset.index, 10);

                     if (!itemsToUpdateByFile[filePath]) {
                        itemsToUpdateByFile[filePath] = [];
                    }
                    itemsToUpdateByFile[filePath].push(index);


                    // Update UI
                    const statusSpan = itemElement.querySelector('.status');
                    statusSpan.classList.remove('status-pending');
                    statusSpan.classList.add('status-extracted');
                    statusSpan.textContent = 'Completed';

                    // Update in-memory data
                    if (allData[filePath] && allData[filePath][index]) {
                        allData[filePath][index].extracted = true;
                         console.log(`Simulating update for: ${JSON.stringify(allData[filePath][index])}`);
                    }

                    // Uncheck and deselect
                    itemElement.classList.remove('selected');
                    if(checkbox) checkbox.checked = false;
                }
            });

             // Log intended changes
            for (const path in itemsToUpdateByFile) {
                console.log(`File: ${path}, Indices to mark complete: ${itemsToUpdateByFile[path].join(', ')}`);
            }
            console.log("--------------------------------------");

            selectedItems.clear();
            updateActionButtons();
            // Note: Actual file writing is not performed here.
             alert('Selected items marked as complete in the view. File updates require backend implementation.');
        }

        async function loadAllData() {
            loadingIndicator.classList.remove('hidden');
            dataContainer.innerHTML = ''; // Clear previous data/headers

            const promises = filePaths.map(async (filePath) => {
                const data = await fetchData(filePath);
                allData[filePath] = data; // Store fetched data
            });

            await Promise.all(promises);

            loadingIndicator.classList.add('hidden');
            renderData();
            updateActionButtons(); // Initial state
        }

        // Add event listeners to buttons
        deleteButton.addEventListener('click', deleteSelectedItems);
        completeButton.addEventListener('click', markSelectedItemsComplete);

        // Initial load
        loadAllData();
    </script>
</body>
</html>
