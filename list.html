<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>데이터 뷰어</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .data-item {
            display: grid; /* Use grid for column layout */
            grid-template-columns: auto 1fr auto auto; /* Checkbox, Title, Details, Status */
            align-items: center;
            gap: 16px; /* Gap between columns */
            padding: 10px 12px; /* Reduced padding */
            border-bottom: 1px solid #e5e7eb;
            transition: background-color 0.2s;
        }
        .data-item:hover {
            background-color: #f3f4f6;
        }
        .data-item.selected {
            background-color: #dbeafe;
        }
        .data-item input[type="checkbox"] {
            margin-right: 0; /* Remove margin, use grid gap */
            grid-column: 1 / 2; /* Place in first column */
        }
        /* Removed .data-item > div as grid handles layout now */
        .data-item .title {
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            grid-column: 2 / 3; /* Place in second column */
        }
        .data-item .details {
            font-size: 0.85em; /* Slightly smaller */
            color: #4b5563;
            white-space: nowrap;
            grid-column: 3 / 4; /* Place in third column */
            display: flex; /* Use flex for tags inside */
            gap: 6px; /* Gap between tags */
        }
        /* Tag styling for details */
        .tag {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .tag-region { background-color: #e0f2fe; color: #0c4a6e; } /* Light Blue */
        .tag-keyword { background-color: #dcfce7; color: #166534; } /* Light Green */
        .tag-date { background-color: #f3f4f6; color: #4b5563; } /* Light Gray */

        .data-item .status {
            font-size: 0.8em;
            padding: 3px 8px;
            border-radius: 6px;
            white-space: nowrap;
            font-weight: 500;
            grid-column: 4 / 5; /* Place in fourth column */
            justify-self: end; /* Align status to the right */
        }
        .status-extracted {
            background-color: #dcfce7;
            color: #166534;
        }
        .status-pending {
            background-color: #fef9c3;
            color: #854d0e;
        }
        .file-header {
            background-color: #e5e7eb;
            padding: 8px 12px; /* Reduced padding */
            font-weight: 600;
            margin-top: 16px; /* Reduced margin */
            border-bottom: 2px solid #d1d5db;
            color: #374151;
            font-size: 1.05em; /* Slightly smaller */
            cursor: pointer; /* Add pointer cursor */
            transition: background-color 0.2s;
        }
        .file-header:hover {
            background-color: #d1d5db; /* Darken on hover */
        }
        #action-buttons {
            position: sticky;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 12px 24px; /* Increased padding */
            border-top: 1px solid #d1d5db; /* Tailwind gray-300 */
            box-shadow: 0 -2px 6px rgba(0,0,0,0.08); /* Softer shadow */
            display: flex;
            gap: 12px; /* Increased gap */
            justify-content: flex-end;
        }
    </style>
    <!-- Add Google Font Inter for a cleaner look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-2 sm:p-4"> <!-- Reduced padding for left shift -->
        <header class="mb-6"> <!-- Reduced margin -->
            <h1 class="text-2xl font-bold text-gray-900">데이터 개요</h1> <!-- Slightly smaller -->
        </header>

        <!-- Filter Section -->
        <div id="filter-container" class="mb-6 p-4 bg-white rounded-lg shadow-sm">
             <h2 class="text-lg font-semibold mb-3 text-gray-700">필터</h2>
             <div class="flex flex-wrap gap-2" id="keyword-filters">
                 <span class="text-sm font-medium text-gray-500 w-full mb-1">키워드:</span>
                 <!-- Keyword buttons will be loaded here -->
             </div>
             <div class="flex flex-wrap gap-2 mt-3" id="region-filters">
                 <span class="text-sm font-medium text-gray-500 w-full mb-1">지역:</span>
                 <!-- Region buttons will be loaded here -->
             </div>
             <button id="show-all-btn" class="mt-3 px-3 py-1 bg-gray-200 text-gray-700 rounded text-sm hover:bg-gray-300 transition">전체 보기</button>
        </div>
        <!-- End Filter Section -->

        <div id="data-container" class="bg-white rounded-lg shadow-md overflow-hidden"> <!-- Added shadow-md, rounded-lg -->
            <!-- Data will be loaded here -->
            <div id="loading" class="p-8 text-center text-gray-600">데이터 로딩 중...</div> <!-- Increased padding -->
        </div>

        <div id="action-buttons" class="hidden mt-4">
             <span id="selected-count" class="mr-4 self-center text-gray-600">0개 선택됨</span>
            <button id="complete-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">
                완료 처리
            </button>
            <button id="delete-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">
                선택 삭제
            </button>
        </div>
    </div>

    <script>
        const dataContainer = document.getElementById('data-container');
        const loadingIndicator = document.getElementById('loading');
        const actionButtonsContainer = document.getElementById('action-buttons');
        const deleteButton = document.getElementById('delete-btn');
        const completeButton = document.getElementById('complete-btn');
        const selectedCountSpan = document.getElementById('selected-count');

        // Removed hardcoded filePaths array

        let allData = {}; // Store data keyed by file path
        let selectedItems = new Set(); // Store unique IDs of selected items
        let lastCheckedCheckbox = null; // To track the last checkbox clicked for shift-select
        let uniqueKeywords = new Set();
        let uniqueRegions = new Set();
        let currentFilter = { keyword: null, region: null }; // To store active filters

        const filterContainer = document.getElementById('filter-container');
        const keywordFiltersContainer = document.getElementById('keyword-filters');
        const regionFiltersContainer = document.getElementById('region-filters');
        const showAllButton = document.getElementById('show-all-btn');


        async function fetchData(filePath) {
            try {
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${filePath}`);
                }
                return await response.json();
            } catch (error) {
                console.error(`Error fetching ${filePath}:`, error);
                return []; // Return empty array on error
            }
        }

        function renderFilters() {
            // Clear existing buttons except labels
            keywordFiltersContainer.innerHTML = '<span class="text-sm font-medium text-gray-500 w-full mb-1">키워드:</span>';
            regionFiltersContainer.innerHTML = '<span class="text-sm font-medium text-gray-500 w-full mb-1">지역:</span>';

            if (uniqueKeywords.size === 0 && uniqueRegions.size === 0) {
                filterContainer.classList.add('hidden'); // Hide filters if none found
                return;
            } else {
                 filterContainer.classList.remove('hidden');
            }

            // Sort for consistent order
            const sortedKeywords = Array.from(uniqueKeywords).sort();
            const sortedRegions = Array.from(uniqueRegions).sort();

            sortedKeywords.forEach(keyword => {
                const button = document.createElement('button');
                button.textContent = keyword;
                button.dataset.keyword = keyword;
                button.className = `filter-btn keyword-btn px-3 py-1 rounded text-sm transition ${currentFilter.keyword === keyword ? 'bg-blue-500 text-white font-semibold' : 'bg-blue-100 text-blue-700 hover:bg-blue-200'}`;
                button.addEventListener('click', () => applyFilter('keyword', keyword));
                keywordFiltersContainer.appendChild(button);
            });

            sortedRegions.forEach(region => {
                const button = document.createElement('button');
                button.textContent = region;
                button.dataset.region = region;
                 button.className = `filter-btn region-btn px-3 py-1 rounded text-sm transition ${currentFilter.region === region ? 'bg-green-500 text-white font-semibold' : 'bg-green-100 text-green-700 hover:bg-green-200'}`;
                button.addEventListener('click', () => applyFilter('region', region));
                regionFiltersContainer.appendChild(button);
            });
        }

        function applyFilter(type, value) {
            // If clicking the same filter again, remove it
            if (currentFilter[type] === value) {
                currentFilter[type] = null;
            } else {
                currentFilter[type] = value;
            }
            renderData(); // Re-render data with the new filter
            renderFilters(); // Re-render filters to update active styles
        }

        function clearFilters() {
            currentFilter = { keyword: null, region: null };
            renderData();
            renderFilters();
        }


        function renderData() {
            dataContainer.innerHTML = ''; // Clear previous content
            loadingIndicator.classList.add('hidden'); // Hide loading initially if called again

            let filteredItemCount = 0;
            const filePathsToRender = Object.keys(allData);

            if (filePathsToRender.length === 0) {
                dataContainer.innerHTML = '<div class="p-8 text-center text-gray-500">결과 폴더에 표시할 JSON 파일이 없습니다.</div>';
                return;
            }

            filePathsToRender.forEach(filePath => {
                const originalData = allData[filePath];
                if (!originalData || originalData.length === 0) return;

                // Filter data based on currentFilter
                const filteredData = originalData.filter(item => {
                    const keywordMatch = !currentFilter.keyword || (item.keyword && item.keyword.toLowerCase() === currentFilter.keyword.toLowerCase());
                    // Ensure city comparison is also case-insensitive
                    const regionMatch = !currentFilter.region || (item.city && item.city.toLowerCase() === currentFilter.region.toLowerCase());
                    return keywordMatch && regionMatch;
                });

                if (filteredData.length === 0) return; // Skip rendering this file if no items match the filter

                filteredItemCount += filteredData.length;

                // --- Create File Header ---
                 // Show filtered count in header if filters are active
                const isFiltered = currentFilter.keyword || currentFilter.region;
                const countText = isFiltered ? `${filteredData.length} / ${originalData.length}개 항목` : `${originalData.length}개 항목`;

                const fileHeader = document.createElement('div');
                fileHeader.className = 'file-header';
                fileHeader.dataset.filePath = filePath; // Add data attribute for identification

                // Extract keyword and city from the first item of the *original* data for the header
                let headerText = filePath; // Default to file path
                if (originalData && originalData.length > 0) {
                    const firstItem = originalData[0];
                    if (firstItem && firstItem.keyword && firstItem.city) {
                        headerText = `${firstItem.keyword} - ${firstItem.city}`;
                    } else if (firstItem && firstItem.keyword) {
                        headerText = firstItem.keyword; // Fallback if city is missing
                    } else if (firstItem && firstItem.city) {
                        headerText = firstItem.city; // Fallback if keyword is missing
                    }
                }
                 // Add count of items in the file
                headerText += ` (${countText})`;

                fileHeader.textContent = headerText;
                fileHeader.addEventListener('click', handleHeaderClick); // Add click listener
                dataContainer.appendChild(fileHeader);
                // --- End File Header Creation ---

                // Add filtered data items
                filteredData.forEach((item) => {
                     // Find the original index for consistent ID generation
                    const originalIndex = originalData.findIndex(originalItem => originalItem === item); // Find based on object reference
                    if (originalIndex === -1) {
                        console.warn("Could not find original index for item:", item);
                        return; // Skip if we can't find the original index (should not happen ideally)
                    }
                    const uniqueId = `${filePath}-${originalIndex}`; // Use original index for ID

                    const itemElement = document.createElement('div');
                    itemElement.className = 'data-item';
                    itemElement.dataset.id = uniqueId;
                    itemElement.dataset.filePath = filePath;
                    itemElement.dataset.index = originalIndex; // Store original index

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = selectedItems.has(uniqueId);
                    if (checkbox.checked) {
                        itemElement.classList.add('selected');
                    }
                    checkbox.dataset.id = uniqueId;
                    checkbox.dataset.filePath = filePath; // Add file path to checkbox for grouping
                    checkbox.addEventListener('change', handleSelectionChange);

                    // No contentDiv needed with grid

                    const titleSpan = document.createElement('span');
                    titleSpan.className = 'title';
                    titleSpan.textContent = item.title;
                    titleSpan.title = item.title;

                    // Create details with tags
                    const detailsSpan = document.createElement('span');
                    detailsSpan.className = 'details';
                    detailsSpan.innerHTML = `
                        <span class="tag tag-region">${item.city || 'N/A'}</span>
                        <span class="tag tag-keyword">${item.keyword || 'N/A'}</span>
                        <span class="tag tag-date">${item.fromDate || ''} ~ ${item.toDate || ''}</span>
                    `;

                    const statusSpan = document.createElement('span');
                    statusSpan.className = 'status';
                    if (item.extracted) {
                        statusSpan.classList.add('status-extracted');
                        statusSpan.textContent = '완료';
                    } else {
                        statusSpan.classList.add('status-pending');
                        statusSpan.textContent = '대기';
                    }

                    // Append elements directly to the grid item
                    itemElement.appendChild(checkbox);
                    itemElement.appendChild(titleSpan);
                    itemElement.appendChild(detailsSpan);
                    itemElement.appendChild(statusSpan);
                    dataContainer.appendChild(itemElement);
                });
            });

            // Add message if no items match the current filter but there is data overall
            if (filteredItemCount === 0 && filePathsToRender.length > 0 && Object.keys(allData).length > 0) {
                 dataContainer.innerHTML = '<div class="p-8 text-center text-gray-500">선택한 필터와 일치하는 항목이 없습니다.</div>';
            }
        }

        function handleSelectionChange(event) {
            const currentCheckbox = event.target;
            const uniqueId = currentCheckbox.dataset.id;
            const currentItemElement = document.querySelector(`.data-item[data-id="${uniqueId}"]`);

            // Get all currently visible checkboxes in the data container
            const allCheckboxes = Array.from(dataContainer.querySelectorAll('.data-item input[type="checkbox"]'));

            if (lastCheckedCheckbox && event.shiftKey) {
                // Shift key is pressed, select range
                const startIndex = allCheckboxes.indexOf(lastCheckedCheckbox);
                const endIndex = allCheckboxes.indexOf(currentCheckbox);

                // Determine the actual start and end for iteration
                const lowerIndex = Math.min(startIndex, endIndex);
                const upperIndex = Math.max(startIndex, endIndex);

                for (let i = lowerIndex; i <= upperIndex; i++) {
                    const checkboxInRange = allCheckboxes[i];
                    const itemElementInRange = checkboxInRange.closest('.data-item'); // Find parent item
                    const idInRange = checkboxInRange.dataset.id;

                    if (checkboxInRange && itemElementInRange) {
                        // Set checked state to match the currently clicked checkbox
                        checkboxInRange.checked = currentCheckbox.checked;

                        // Update selectedItems set and visual style
                        if (currentCheckbox.checked) {
                            selectedItems.add(idInRange);
                            itemElementInRange.classList.add('selected');
                        } else {
                            selectedItems.delete(idInRange);
                            itemElementInRange.classList.remove('selected');
                        }
                    }
                }
            } else {
                // Normal click (no shift or no previous check)
                if (currentCheckbox.checked) {
                    selectedItems.add(uniqueId);
                    currentItemElement.classList.add('selected');
                } else {
                    selectedItems.delete(uniqueId);
                    currentItemElement.classList.remove('selected');
                }
                // Update lastCheckedCheckbox only on non-shift clicks
                lastCheckedCheckbox = currentCheckbox;
            }

            updateActionButtons();
        }

        // --- New Function for Header Click ---
        function handleHeaderClick(event) {
            const headerElement = event.currentTarget;
            const filePath = headerElement.dataset.filePath;

            // Find all checkboxes belonging to this file group that are currently visible
            const checkboxesInGroup = Array.from(dataContainer.querySelectorAll(`.data-item input[type="checkbox"][data-file-path="${filePath}"]`));

            if (checkboxesInGroup.length === 0) return; // No checkboxes to toggle

            // Determine if we should check or uncheck all
            // Check if *all* checkboxes in the group are already checked
            const allChecked = checkboxesInGroup.every(cb => cb.checked);
            const shouldCheck = !allChecked; // If all are checked, we uncheck; otherwise, we check

            checkboxesInGroup.forEach(checkbox => {
                const uniqueId = checkbox.dataset.id;
                const itemElement = checkbox.closest('.data-item');

                if (checkbox.checked !== shouldCheck) { // Only change if needed
                    checkbox.checked = shouldCheck;

                    // Update selectedItems set and visual style
                    if (shouldCheck) {
                        selectedItems.add(uniqueId);
                        itemElement.classList.add('selected');
                    } else {
                        selectedItems.delete(uniqueId);
                        itemElement.classList.remove('selected');
                    }
                }
            });

            // Reset lastCheckedCheckbox after a group toggle to avoid unexpected shift-click behavior
            lastCheckedCheckbox = null;
            updateActionButtons(); // Update the count and button visibility
        }
        // --- End New Function ---

        function updateActionButtons() {
            const count = selectedItems.size;
             selectedCountSpan.textContent = `${count}개 선택됨`;
            if (count > 0) {
                actionButtonsContainer.classList.remove('hidden');
            } else {
                actionButtonsContainer.classList.add('hidden');
            }
        }

        function deleteSelectedItems() {
            if (selectedItems.size === 0) return;

            console.log("--- Deleting Items (UI Only) ---");
            const itemsToDeleteByFile = {};

            selectedItems.forEach(uniqueId => {
                const itemElement = document.querySelector(`.data-item[data-id="${uniqueId}"]`);
                if (itemElement) {
                    const filePath = itemElement.dataset.filePath;
                    const index = parseInt(itemElement.dataset.index, 10);

                    if (!itemsToDeleteByFile[filePath]) {
                        itemsToDeleteByFile[filePath] = [];
                    }
                    // Store the original index to identify the item in the JSON
                    itemsToDeleteByFile[filePath].push(index);

                    itemElement.remove(); // Remove from UI
                }
            });

            // Log intended changes (in a real app, this would trigger backend updates)
            for (const path in itemsToDeleteByFile) {
                console.log(`File: ${path}, Indices to delete: ${itemsToDeleteByFile[path].sort((a, b) => b - a).join(', ')}`);
                // Important: Indices need to be deleted in reverse order to avoid shifting issues
                const indicesToDelete = itemsToDeleteByFile[path].sort((a, b) => b - a); // Sort descending
                indicesToDelete.forEach(index => {
                    if (allData[path] && allData[path][index]) {
                         console.log(`Simulating deletion of: ${JSON.stringify(allData[path][index])}`);
                         allData[path].splice(index, 1); // Update in-memory data
                    }
                });
            }
             console.log("---------------------------------");


            selectedItems.clear();
            updateActionButtons();
            // Note: Actual file writing is not performed here.
            alert('Selected items removed from the view. File updates require backend implementation.');
        }

        function markSelectedItemsComplete() {
            if (selectedItems.size === 0) return;

            console.log("--- Processing Completion ---");

            const itemsToProcess = [];
            const processedIds = new Set(); // Keep track of IDs processed

            // 1. Gather data for selected items FIRST
            selectedItems.forEach(uniqueId => {
                const itemElement = document.querySelector(`.data-item[data-id="${uniqueId}"]`);
                if (!itemElement) {
                    console.warn(`Could not find element for selected ID: ${uniqueId}`);
                    return;
                }

                const filePath = itemElement.dataset.filePath;
                const index = parseInt(itemElement.dataset.index, 10);

                if (allData[filePath] && allData[filePath][index]) {
                    const itemData = allData[filePath][index];
                    const blogUrl = itemData.link; // Use 'link' field from JSON

                    if (!blogUrl) {
                        console.warn(`Skipping item ${uniqueId}: Blog link (URL) not found in data.`);
                        alert(`데이터 오류: ${uniqueId} 항목에 link(URL)가 없습니다.`);
                        return; // Skip if no link
                    }

                    itemsToProcess.push({
                        uniqueId: uniqueId,
                        blogUrl: blogUrl,
                        title: itemData.title,
                        region: itemData.city, // Assuming 'city' maps to region
                        keyword: itemData.keyword,
                        filePath: filePath,
                        index: index
                    });

                } else {
                     console.warn(`Could not find data for selected ID: ${uniqueId} (Path: ${filePath}, Index: ${index})`);
                     alert(`데이터 오류: ${uniqueId} 항목의 정보를 찾을 수 없습니다.`);
                }
            });

            if (itemsToProcess.length === 0) {
                 console.log("No valid items to process.");
                 // Clear selection even if nothing was processed
                 selectedItems.clear();
                 updateActionButtons();
                 return;
            }

            // 2. Send requests to backend
            console.log(`Sending ${itemsToProcess.length} download requests...`);
            const downloadPromises = itemsToProcess.map(item => {
                 console.log(`Requesting download for: ${item.blogUrl} (Title: ${item.title}, Region: ${item.region}, Keyword: ${item.keyword})`);
                 return fetch('/api/download-blog', {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                     },
                     body: JSON.stringify({
                         blogUrl: item.blogUrl,
                         title: item.title,
                         region: item.region,
                         keyword: item.keyword
                     }),
                 })
                 .then(response => response.json())
                 .then(data => {
                     if (data.success) {
                         console.log(`Download successful for ${item.blogUrl}: ${data.folderPath}`);
                         processedIds.add(item.uniqueId); // Mark as successfully processed
                     } else {
                         console.error(`Download failed for ${item.blogUrl}: ${data.message || 'Unknown error'}`);
                         alert(`블로그 다운로드 실패: ${item.blogUrl}\n${data.message || ''}`);
                     }
                     return data.success; // Return success status
                 })
                 .catch(error => {
                     console.error(`Error sending download request for ${item.blogUrl}:`, error);
                     alert(`블로그 다운로드 요청 중 오류 발생: ${item.blogUrl}`);
                     return false; // Indicate failure
                 });
            });

            // 3. Wait for all requests and update UI for successfully processed items
            Promise.all(downloadPromises).then((results) => {
                console.log("All download requests finished.");
                let successCount = 0;

                processedIds.forEach(uniqueId => {
                     const itemElement = document.querySelector(`.data-item[data-id="${uniqueId}"]`);
                     const checkbox = itemElement?.querySelector('input[type="checkbox"]');
                     if (itemElement) {
                         // Update UI
                         const statusSpan = itemElement.querySelector('.status');
                         if (statusSpan) {
                             statusSpan.classList.remove('status-pending');
                             statusSpan.classList.add('status-extracted');
                             statusSpan.textContent = '완료'; // Changed from 'Completed'
                         }

                         // Update in-memory data (optional but good practice)
                         const filePath = itemElement.dataset.filePath;
                         const index = parseInt(itemElement.dataset.index, 10);
                         if (allData[filePath] && allData[filePath][index]) {
                             allData[filePath][index].extracted = true;
                         }

                         // Uncheck and deselect visually
                         itemElement.classList.remove('selected');
                         if (checkbox) checkbox.checked = false;
                         successCount++;
                     }
                });

                // 4. Clear selection and update buttons
                selectedItems.clear();
                updateActionButtons();

                alert(`${successCount} / ${itemsToProcess.length}개 항목의 다운로드 요청이 성공적으로 처리되었습니다. 실패한 항목은 콘솔을 확인하세요.`);

                // Optionally reload data to reflect changes persisted on the backend (if any)
                // loadAllData();
            });
        }

        async function loadAllData() {
            loadingIndicator.classList.remove('hidden');
            dataContainer.innerHTML = '<div id="loading" class="p-8 text-center text-gray-600">데이터 로딩 중...</div>'; // Show loading
            allData = {}; // Clear previous data
            uniqueKeywords.clear(); // Clear previous filters
            uniqueRegions.clear(); // Clear previous filters
            currentFilter = { keyword: null, region: null }; // Reset filters on load

            try {
                // 1. Fetch the list of JSON filenames from the server
                const response = await fetch('/api/results');
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: 'Failed to fetch file list.' }));
                    throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                }
                const result = await response.json();

                if (!result.success || !result.files || result.files.length === 0) {
                    loadingIndicator.classList.add('hidden');
                    dataContainer.innerHTML = '<div class="p-8 text-center text-gray-500">결과 폴더에서 JSON 파일을 찾을 수 없습니다.</div>';
                    updateActionButtons();
                    return;
                }

                const fetchedFilePaths = result.files.map(filename => `result/${filename}`); // Construct full paths

                // 2. Fetch data for each file
                const promises = fetchedFilePaths.map(async (filePath) => {
                    const data = await fetchData(filePath);
                    if (data && data.length > 0) { // Only store if data is valid and not empty
                       allData[filePath] = data;
                    } else {
                        console.warn(`No valid data found or empty file: ${filePath}`);
                    }
                });

                await Promise.all(promises);

                // 3. Extract unique keywords and regions from all loaded data
                Object.values(allData).flat().forEach(item => {
                    if (item.keyword) uniqueKeywords.add(item.keyword);
                    if (item.city) uniqueRegions.add(item.city); // Assuming 'city' is the field for region
                });

                // 4. Render filters and then data
                renderFilters(); // Render filter buttons first
                renderData(); // Render data (initially unfiltered)

            } catch (error) {
                console.error('Error loading data:', error);
                renderFilters(); // Still try to render filters even on error? Maybe hide them.
                filterContainer.classList.add('hidden'); // Hide filters on error
                loadingIndicator.classList.add('hidden');
                dataContainer.innerHTML = `<div class="p-8 text-center text-red-600">데이터 로딩 실패: ${error.message}</div>`;
            } finally {
                 // Ensure loading indicator is hidden even if renderData clears it
                const currentLoading = dataContainer.querySelector('#loading');
                if (currentLoading) currentLoading.classList.add('hidden');
                updateActionButtons(); // Update button visibility
            }
        }

        // Add event listeners to buttons
        deleteButton.addEventListener('click', deleteSelectedItems);
        completeButton.addEventListener('click', markSelectedItemsComplete);
        showAllButton.addEventListener('click', clearFilters); // Add listener for show all

        // Initial load
        loadAllData();
    </script>
</body>
</html>
