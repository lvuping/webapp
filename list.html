<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>데이터 뷰어</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Using a nicer sans-serif font */
        }
        .data-item {
            display: flex;
            align-items: center;
            /* Increased padding for better spacing */
            padding: 12px 16px;
            border-bottom: 1px solid #e5e7eb; /* Tailwind gray-200 */
            transition: background-color 0.2s;
        }
        .data-item:hover {
            background-color: #f3f4f6; /* Tailwind gray-100 */
        }
        .data-item.selected {
            background-color: #dbeafe; /* Tailwind blue-100 */
        }
        .data-item input[type="checkbox"] {
            margin-right: 16px; /* Increased margin */
            flex-shrink: 0;
        }
        .data-item > div {
            flex-grow: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px; /* Increased gap */
            overflow: hidden; /* Prevent long text from breaking layout */
        }
        .data-item .title {
            font-weight: 600; /* Slightly bolder */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-basis: 45%; /* Adjusted basis */
        }
        .data-item .details {
            font-size: 0.9em;
            color: #4b5563; /* Tailwind gray-600 */
            white-space: nowrap;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .data-item .status {
            font-size: 0.8em;
            padding: 3px 8px; /* Slightly larger padding */
            border-radius: 6px; /* More rounded */
            white-space: nowrap;
            flex-shrink: 0;
            font-weight: 500;
        }
        .status-extracted {
            background-color: #dcfce7; /* Tailwind green-100 */
            color: #166534; /* Tailwind green-800 */
        }
        .status-pending {
            background-color: #fef9c3; /* Tailwind yellow-100 */
            color: #854d0e; /* Tailwind yellow-800 */
        }
        .file-header {
            background-color: #e5e7eb; /* Tailwind gray-200 */
            padding: 10px 16px; /* Increased padding */
            font-weight: 600; /* Bolder */
            margin-top: 20px; /* Increased margin */
            border-bottom: 2px solid #d1d5db; /* Tailwind gray-300 */
            color: #374151; /* Tailwind gray-700 */
            font-size: 1.1em; /* Slightly larger font */
        }
        #action-buttons {
            position: sticky;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 12px 24px; /* Increased padding */
            border-top: 1px solid #d1d5db; /* Tailwind gray-300 */
            box-shadow: 0 -2px 6px rgba(0,0,0,0.08); /* Softer shadow */
            display: flex;
            gap: 12px; /* Increased gap */
            justify-content: flex-end;
        }
    </style>
    <!-- Add Google Font Inter for a cleaner look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100"> <!-- Slightly darker background -->
    <div class="container mx-auto p-4 sm:p-8"> <!-- Increased padding -->
        <header class="mb-8"> <!-- Increased margin -->
            <h1 class="text-3xl font-bold text-gray-900">데이터 개요</h1> <!-- Darker text, larger size -->
        </header>

        <!-- Filter Section -->
        <div id="filter-container" class="mb-6 p-4 bg-white rounded-lg shadow-sm">
             <h2 class="text-lg font-semibold mb-3 text-gray-700">필터</h2>
             <div class="flex flex-wrap gap-2" id="keyword-filters">
                 <span class="text-sm font-medium text-gray-500 w-full mb-1">키워드:</span>
                 <!-- Keyword buttons will be loaded here -->
             </div>
             <div class="flex flex-wrap gap-2 mt-3" id="region-filters">
                 <span class="text-sm font-medium text-gray-500 w-full mb-1">지역:</span>
                 <!-- Region buttons will be loaded here -->
             </div>
             <button id="show-all-btn" class="mt-3 px-3 py-1 bg-gray-200 text-gray-700 rounded text-sm hover:bg-gray-300 transition">전체 보기</button>
        </div>
        <!-- End Filter Section -->

        <div id="data-container" class="bg-white rounded-lg shadow-md overflow-hidden"> <!-- Added shadow-md, rounded-lg -->
            <!-- Data will be loaded here -->
            <div id="loading" class="p-8 text-center text-gray-600">데이터 로딩 중...</div> <!-- Increased padding -->
        </div>

        <div id="action-buttons" class="hidden mt-4">
             <span id="selected-count" class="mr-4 self-center text-gray-600">0개 선택됨</span>
            <button id="complete-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">
                완료 처리
            </button>
            <button id="delete-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">
                선택 삭제
            </button>
        </div>
    </div>

    <script>
        const dataContainer = document.getElementById('data-container');
        const loadingIndicator = document.getElementById('loading');
        const actionButtonsContainer = document.getElementById('action-buttons');
        const deleteButton = document.getElementById('delete-btn');
        const completeButton = document.getElementById('complete-btn');
        const selectedCountSpan = document.getElementById('selected-count');

        // Removed hardcoded filePaths array

        let allData = {}; // Store data keyed by file path
        let selectedItems = new Set(); // Store unique IDs of selected items
        let uniqueKeywords = new Set();
        let uniqueRegions = new Set();
        let currentFilter = { keyword: null, region: null }; // To store active filters

        const filterContainer = document.getElementById('filter-container');
        const keywordFiltersContainer = document.getElementById('keyword-filters');
        const regionFiltersContainer = document.getElementById('region-filters');
        const showAllButton = document.getElementById('show-all-btn');


        async function fetchData(filePath) {
            try {
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${filePath}`);
                }
                return await response.json();
            } catch (error) {
                console.error(`Error fetching ${filePath}:`, error);
                return []; // Return empty array on error
            }
        }

        function renderFilters() {
            // Clear existing buttons except labels
            keywordFiltersContainer.innerHTML = '<span class="text-sm font-medium text-gray-500 w-full mb-1">키워드:</span>';
            regionFiltersContainer.innerHTML = '<span class="text-sm font-medium text-gray-500 w-full mb-1">지역:</span>';

            if (uniqueKeywords.size === 0 && uniqueRegions.size === 0) {
                filterContainer.classList.add('hidden'); // Hide filters if none found
                return;
            } else {
                 filterContainer.classList.remove('hidden');
            }

            // Sort for consistent order
            const sortedKeywords = Array.from(uniqueKeywords).sort();
            const sortedRegions = Array.from(uniqueRegions).sort();

            sortedKeywords.forEach(keyword => {
                const button = document.createElement('button');
                button.textContent = keyword;
                button.dataset.keyword = keyword;
                button.className = `filter-btn keyword-btn px-3 py-1 rounded text-sm transition ${currentFilter.keyword === keyword ? 'bg-blue-500 text-white font-semibold' : 'bg-blue-100 text-blue-700 hover:bg-blue-200'}`;
                button.addEventListener('click', () => applyFilter('keyword', keyword));
                keywordFiltersContainer.appendChild(button);
            });

            sortedRegions.forEach(region => {
                const button = document.createElement('button');
                button.textContent = region;
                button.dataset.region = region;
                 button.className = `filter-btn region-btn px-3 py-1 rounded text-sm transition ${currentFilter.region === region ? 'bg-green-500 text-white font-semibold' : 'bg-green-100 text-green-700 hover:bg-green-200'}`;
                button.addEventListener('click', () => applyFilter('region', region));
                regionFiltersContainer.appendChild(button);
            });
        }

        function applyFilter(type, value) {
            // If clicking the same filter again, remove it
            if (currentFilter[type] === value) {
                currentFilter[type] = null;
            } else {
                currentFilter[type] = value;
            }
            renderData(); // Re-render data with the new filter
            renderFilters(); // Re-render filters to update active styles
        }

        function clearFilters() {
            currentFilter = { keyword: null, region: null };
            renderData();
            renderFilters();
        }


        function renderData() {
            dataContainer.innerHTML = ''; // Clear previous content
            loadingIndicator.classList.add('hidden'); // Hide loading initially if called again

            let filteredItemCount = 0;
            const filePathsToRender = Object.keys(allData);

            if (filePathsToRender.length === 0) {
                dataContainer.innerHTML = '<div class="p-8 text-center text-gray-500">결과 폴더에 표시할 JSON 파일이 없습니다.</div>';
                return;
            }

            filePathsToRender.forEach(filePath => {
                const originalData = allData[filePath];
                if (!originalData || originalData.length === 0) return;

                // Filter data based on currentFilter
                const filteredData = originalData.filter(item => {
                    const keywordMatch = !currentFilter.keyword || (item.keyword && item.keyword.toLowerCase() === currentFilter.keyword.toLowerCase());
                    // Ensure city comparison is also case-insensitive
                    const regionMatch = !currentFilter.region || (item.city && item.city.toLowerCase() === currentFilter.region.toLowerCase());
                    return keywordMatch && regionMatch;
                });

                if (filteredData.length === 0) return; // Skip rendering this file if no items match the filter

                filteredItemCount += filteredData.length;

                // --- Create File Header ---
                 // Show filtered count in header if filters are active
                const isFiltered = currentFilter.keyword || currentFilter.region;
                const countText = isFiltered ? `${filteredData.length} / ${originalData.length}개 항목` : `${originalData.length}개 항목`;

                const fileHeader = document.createElement('div');
                fileHeader.className = 'file-header';

                // Extract keyword and city from the first item of the *original* data for the header
                let headerText = filePath; // Default to file path
                if (originalData && originalData.length > 0) { // Check if originalData exists and is not empty
                    const firstItem = originalData[0];
                    if (firstItem && firstItem.keyword && firstItem.city) {
                        headerText = `${firstItem.keyword} - ${firstItem.city}`;
                    } else if (firstItem && firstItem.keyword) {
                        headerText = firstItem.keyword; // Fallback if city is missing
                    } else if (firstItem && firstItem.city) {
                        headerText = firstItem.city; // Fallback if keyword is missing
                    }
                }
                 // Add count of items in the file
                headerText += ` (${countText})`; // Use dynamic count text

                fileHeader.textContent = headerText;
                dataContainer.appendChild(fileHeader);
                // --- End File Header Creation ---

                // Add filtered data items
                filteredData.forEach((item) => {
                     // Find the original index for consistent ID generation
                    const originalIndex = originalData.findIndex(originalItem => originalItem === item); // Find based on object reference
                    if (originalIndex === -1) {
                        console.warn("Could not find original index for item:", item);
                        return; // Skip if we can't find the original index (should not happen ideally)
                    }
                    const uniqueId = `${filePath}-${originalIndex}`; // Use original index for ID

                    const itemElement = document.createElement('div');
                    itemElement.className = 'data-item';
                    itemElement.dataset.id = uniqueId;
                    itemElement.dataset.filePath = filePath;
                    itemElement.dataset.index = originalIndex; // Store original index

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    // Check if this item was previously selected
                    checkbox.checked = selectedItems.has(uniqueId);
                    if (checkbox.checked) {
                        itemElement.classList.add('selected'); // Re-apply selected style if needed
                    }
                    checkbox.dataset.id = uniqueId;
                    checkbox.addEventListener('change', handleSelectionChange);

                    const contentDiv = document.createElement('div');

                    const titleSpan = document.createElement('span');
                    titleSpan.className = 'title';
                    titleSpan.textContent = item.title;
                    titleSpan.title = item.title; // Show full title on hover

                    const detailsSpan = document.createElement('span');
                    detailsSpan.className = 'details';
                    detailsSpan.textContent = `${item.city} | ${item.keyword} | ${item.fromDate} ~ ${item.toDate}`;

                    const statusSpan = document.createElement('span');
                    statusSpan.className = 'status';
                    if (item.extracted) {
                        statusSpan.classList.add('status-extracted');
                        statusSpan.textContent = '완료';
                    } else {
                        statusSpan.classList.add('status-pending');
                        statusSpan.textContent = '대기';
                    }

                    contentDiv.appendChild(titleSpan);
                    contentDiv.appendChild(detailsSpan);
                    contentDiv.appendChild(statusSpan);

                    itemElement.appendChild(checkbox);
                    itemElement.appendChild(contentDiv);
                    dataContainer.appendChild(itemElement);
                });
            });

            // Add message if no items match the current filter but there is data overall
            if (filteredItemCount === 0 && filePathsToRender.length > 0 && Object.keys(allData).length > 0) {
                 dataContainer.innerHTML = '<div class="p-8 text-center text-gray-500">선택한 필터와 일치하는 항목이 없습니다.</div>';
            }
        }

        function handleSelectionChange(event) {
            const checkbox = event.target;
            const uniqueId = checkbox.dataset.id;
            const itemElement = document.querySelector(`.data-item[data-id="${uniqueId}"]`);

            if (checkbox.checked) {
                selectedItems.add(uniqueId);
                itemElement.classList.add('selected');
            } else {
                selectedItems.delete(uniqueId);
                itemElement.classList.remove('selected');
            }
            updateActionButtons();
        }

        function updateActionButtons() {
            const count = selectedItems.size;
             selectedCountSpan.textContent = `${count}개 선택됨`;
            if (count > 0) {
                actionButtonsContainer.classList.remove('hidden');
            } else {
                actionButtonsContainer.classList.add('hidden');
            }
        }

        function deleteSelectedItems() {
            if (selectedItems.size === 0) return;

            console.log("--- Deleting Items (UI Only) ---");
            const itemsToDeleteByFile = {};

            selectedItems.forEach(uniqueId => {
                const itemElement = document.querySelector(`.data-item[data-id="${uniqueId}"]`);
                if (itemElement) {
                    const filePath = itemElement.dataset.filePath;
                    const index = parseInt(itemElement.dataset.index, 10);

                    if (!itemsToDeleteByFile[filePath]) {
                        itemsToDeleteByFile[filePath] = [];
                    }
                    // Store the original index to identify the item in the JSON
                    itemsToDeleteByFile[filePath].push(index);

                    itemElement.remove(); // Remove from UI
                }
            });

            // Log intended changes (in a real app, this would trigger backend updates)
            for (const path in itemsToDeleteByFile) {
                console.log(`File: ${path}, Indices to delete: ${itemsToDeleteByFile[path].sort((a, b) => b - a).join(', ')}`);
                // Important: Indices need to be deleted in reverse order to avoid shifting issues
                const indicesToDelete = itemsToDeleteByFile[path].sort((a, b) => b - a); // Sort descending
                indicesToDelete.forEach(index => {
                    if (allData[path] && allData[path][index]) {
                         console.log(`Simulating deletion of: ${JSON.stringify(allData[path][index])}`);
                         allData[path].splice(index, 1); // Update in-memory data
                    }
                });
            }
             console.log("---------------------------------");


            selectedItems.clear();
            updateActionButtons();
            // Note: Actual file writing is not performed here.
            alert('Selected items removed from the view. File updates require backend implementation.');
        }

        function markSelectedItemsComplete() {
            if (selectedItems.size === 0) return;

            console.log("--- Marking Items Complete (UI Only) ---");
             const itemsToUpdateByFile = {};

            selectedItems.forEach(uniqueId => {
                const itemElement = document.querySelector(`.data-item[data-id="${uniqueId}"]`);
                 const checkbox = itemElement.querySelector('input[type="checkbox"]');
                if (itemElement) {
                    const filePath = itemElement.dataset.filePath;
                    const index = parseInt(itemElement.dataset.index, 10);

                     if (!itemsToUpdateByFile[filePath]) {
                        itemsToUpdateByFile[filePath] = [];
                    }
                    itemsToUpdateByFile[filePath].push(index);


                    // Update UI
                    const statusSpan = itemElement.querySelector('.status');
                    statusSpan.classList.remove('status-pending');
                    statusSpan.classList.add('status-extracted');
                    statusSpan.textContent = 'Completed';

                    // Update in-memory data
                    if (allData[filePath] && allData[filePath][index]) {
                        allData[filePath][index].extracted = true;
                         console.log(`Simulating update for: ${JSON.stringify(allData[filePath][index])}`);
                    }

                    // Uncheck and deselect
                    itemElement.classList.remove('selected');
                    if(checkbox) checkbox.checked = false;
                }
            });

             // Log intended changes
            for (const path in itemsToUpdateByFile) {
                console.log(`File: ${path}, Indices to mark complete: ${itemsToUpdateByFile[path].join(', ')}`);
            }
            console.log("--------------------------------------");

            selectedItems.clear();
            updateActionButtons();
            // Note: Actual file writing is not performed here.
             alert('Selected items marked as complete in the view. File updates require backend implementation.');
        }

        async function loadAllData() {
            loadingIndicator.classList.remove('hidden');
            dataContainer.innerHTML = '<div id="loading" class="p-8 text-center text-gray-600">데이터 로딩 중...</div>'; // Show loading
            allData = {}; // Clear previous data
            uniqueKeywords.clear(); // Clear previous filters
            uniqueRegions.clear(); // Clear previous filters
            currentFilter = { keyword: null, region: null }; // Reset filters on load

            try {
                // 1. Fetch the list of JSON filenames from the server
                const response = await fetch('/api/results');
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: 'Failed to fetch file list.' }));
                    throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                }
                const result = await response.json();

                if (!result.success || !result.files || result.files.length === 0) {
                    loadingIndicator.classList.add('hidden');
                    dataContainer.innerHTML = '<div class="p-8 text-center text-gray-500">결과 폴더에서 JSON 파일을 찾을 수 없습니다.</div>';
                    updateActionButtons();
                    return;
                }

                const fetchedFilePaths = result.files.map(filename => `result/${filename}`); // Construct full paths

                // 2. Fetch data for each file
                const promises = fetchedFilePaths.map(async (filePath) => {
                    const data = await fetchData(filePath);
                    if (data && data.length > 0) { // Only store if data is valid and not empty
                       allData[filePath] = data;
                    } else {
                        console.warn(`No valid data found or empty file: ${filePath}`);
                    }
                });

                await Promise.all(promises);

                // 3. Extract unique keywords and regions from all loaded data
                Object.values(allData).flat().forEach(item => {
                    if (item.keyword) uniqueKeywords.add(item.keyword);
                    if (item.city) uniqueRegions.add(item.city); // Assuming 'city' is the field for region
                });

                // 4. Render filters and then data
                renderFilters(); // Render filter buttons first
                renderData(); // Render data (initially unfiltered)

            } catch (error) {
                console.error('Error loading data:', error);
                renderFilters(); // Still try to render filters even on error? Maybe hide them.
                filterContainer.classList.add('hidden'); // Hide filters on error
                loadingIndicator.classList.add('hidden');
                dataContainer.innerHTML = `<div class="p-8 text-center text-red-600">데이터 로딩 실패: ${error.message}</div>`;
            } finally {
                 // Ensure loading indicator is hidden even if renderData clears it
                const currentLoading = dataContainer.querySelector('#loading');
                if (currentLoading) currentLoading.classList.add('hidden');
                updateActionButtons(); // Update button visibility
            }
        }

        // Add event listeners to buttons
        deleteButton.addEventListener('click', deleteSelectedItems);
        completeButton.addEventListener('click', markSelectedItemsComplete);
        showAllButton.addEventListener('click', clearFilters); // Add listener for show all

        // Initial load
        loadAllData();
    </script>
</body>
</html>
